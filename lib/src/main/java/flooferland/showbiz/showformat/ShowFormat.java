/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package flooferland.showbiz.showformat;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.zip.GZIPInputStream;

// TODO: Make an API for reading/parsing the show intermediate files from an InputStream

// TODO: Add more error handling: Check if the version of the file matches (and exists), etc

public record ShowFormat(ShowBlock signal, ShowBlock audio, ShowBlock video) {
    /** Parses the binary intermediate format and returns a new ShowFormat */
    public static @Nonnull ShowFormat fromIntermediate(InputStream inputStream) throws Exception {
        // Uncompressed and reading the data
        var stream = new GZIPInputStream(inputStream);
        
        // File format header
        String formatHeader = new String(stream.readNBytes(8), StandardCharsets.UTF_8);
        if (!formatHeader.equals("SHOWBIN\0")) {
            throw new Exception(String.format("ERROR: File header \"%s\" doesn't match the format!", formatHeader));
        }
        
        // File metadata
        short version = ByteBuffer.wrap(stream.readNBytes(2)).getShort();
        System.out.printf("Read version '%s' of the format.%n", version);
        stream.skipNBytes(6);
        
        // Parsing
        ShowBlock signal = null;
        ShowBlock audio = null;
        ShowBlock video = null;
        for (int i = 0; i < 3; i++) {
            // First block header
            byte[] header = stream.readNBytes(DataConverter.identBase.length);
            if (!Arrays.equals(header, DataConverter.identBase)) {
                throw new Exception(String.format("ERROR: Block header \"%s\" doesn't match the format.\nThe length specified in the header of the last section might've been wrong.", new String(header, StandardCharsets.UTF_8)));
            }

            // First block id
            int blockIdBytes = (int) stream.read();
            Ident blockId = Ident.fromHex(blockIdBytes);
            if (blockId == null) {
                throw new Exception(String.format(
                        "Block ID doesn't match any known ID: %s\nExamples:\n- Signal section ID: %s\n- Audio section ID: %s\n- Video section ID: %s",
                        Util.toHexString(blockIdBytes),
                        Util.toHexString(Ident.signalByte),
                        Util.toHexString(Ident.audioByte),
                        Util.toHexString(Ident.videoByte)
                ));
            }

            // Block length
            byte[] blockLengthBytes = stream.readNBytes(4);
            int blockLength = ByteBuffer.wrap(blockLengthBytes).getInt();
            stream.skipNBytes(4);

            // Reading the data
            byte[] data = stream.readNBytes(blockLength);
            if (data == null)
                throw new Exception("ERROR: Data is null");
            
            // Adding the block
            switch (blockId) {
                case Signal:
                    signal = new ShowBlock(blockId, data);
                    break;
                case Audio:
                    audio = new ShowBlock(blockId, data);
                    break;
                case Video:
                    video = new ShowBlock(blockId, data);
                    break;
            }
            System.out.printf("Finished reading BlockID '%s'%n%n", blockId);
        }
        
        // Returning
        return new ShowFormat(signal, audio, video);
    }
}
